<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[在VSC里编写调试C/C++程序]]></title>
      <url>/2018/02/06/c-cpp-in-vsc/</url>
      <content type="html"><![CDATA[<p>刚重装完系统，VS里只装了C#，想到可能会用到C/C++，于是乎就用MinGW+VSC搭建一下开发环境。</p>
<h2 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h2><p>现在<a href="http://www.mingw.org/" target="_blank" rel="external">这里</a>找到下载器，然后下载进行安装。安装完成后打开勾选需要安装的选项。这里需要选择三个，分别是：</p>
<ul>
<li>mingw32-gcc</li>
<li>mingw32-gcc-g++</li>
<li>mingw-gdb<br>需要注意的是，要选择<code>class</code>为<code>bin</code>的。如下图为例：<br><a href="/img/2018/02/snipaste_20180206_163843.png"><img src="/img/2018/02/snipaste_20180206_163843.png" alt="MinGW"></a><br>选完之后安装，过程可能会很慢或者直接下载失败，科学上网即可。安装结束之后要配置一下环境变量，添加<code>gdb.exe</code>的路径。如图：<br><a href="/img/2018/02/snipaste_20180206_163807.png"><img src="/img/2018/02/snipaste_20180206_163807.png" alt="EditEnvironmentVariable"></a></li>
</ul>
<h2 id="安装C-C-插件"><a href="#安装C-C-插件" class="headerlink" title="安装C/C++插件"></a>安装C/C++插件</h2><p>在VSC里搜索<code>C/C++</code>然后安装这个插件。<br><a href="/img/2018/02/snipaste_20180206_181253.png"><img src="/img/2018/02/snipaste_20180206_181253.png" alt="C/C++"></a></p>
<h2 id="配置C-C-项目"><a href="#配置C-C-项目" class="headerlink" title="配置C/C++项目"></a>配置C/C++项目</h2><p>一个C/C++项目会的配置文件包含在<code>.vscode</code>文件夹里，里面包含了4个文件，分别是：  </p>
<ul>
<li>c_cpp_properties.json</li>
<li>launch.json</li>
<li>settings.json</li>
<li>task.json<br>只要把这4个文件配置信息写好了我们的Console项目就能运行起来了，这些文件都不需要我们手动创建，下面就讲讲如何创建和填写这4个文件的信息。</li>
</ul>
<h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><p>键盘按住<code>Ctrl+Shift+P</code>，然后输入<code>C/Cpp</code>，然后从中选择<code>Edit Configurations...</code><br><a href="/img/2018/02/snipaste_20180206_164042.png"><img src="/img/2018/02/snipaste_20180206_164042.png" alt="Configurations"></a><br>参考插件<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/MinGW.md" target="_blank" rel="external">官方配置</a>做了些修改，官方的<code>includePath</code>和<code>path</code>这两个属性填写得不够完整。这里给出了我修改后的：</p>
<pre><code>{
    &quot;name&quot;: &quot;Win32&quot;,
    &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;,
    &quot;includePath&quot;: [
        &quot;C:/MinGW/include&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include/c++&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include/c++/mingw32&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include/c++/mingw32/bits&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include-fixed&quot;,
        &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include/c++/tr1&quot;,
        &quot;${workspaceRoot}&quot;
    ],
    &quot;defines&quot;: [
        &quot;_DEBUG&quot;,
        &quot;UNICODE&quot;,
        &quot;__GNUC__=6&quot;,
        &quot;__cdecl=__attribute__((__cdecl__))&quot;
    ],
    &quot;browse&quot;: {
        &quot;path&quot;: [
            &quot;C:/MinGW/include&quot;,
            &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include/c++&quot;,
            &quot;C:/MinGW/lib/gcc/mingw32/6.3.0/include-fixed&quot;,
            &quot;${workspaceRoot}&quot;
        ],
        &quot;limitSymbolsToIncludedHeaders&quot;: true,
        &quot;databaseFilename&quot;: &quot;&quot;
    }
}
</code></pre><p>如果你的VSC提示你找不到头文件，将鼠标放在上边然后就会提示你应该添加什么路径到<code>includePath</code>里了。</p>
<h3 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h3><p>点击左下角的齿轮Button，然后选择Settings。在右侧选择<code>WORKSPACE SETTINGS</code><br><a href="/img/2018/02/snipaste_20180206_183507.png"><img src="/img/2018/02/snipaste_20180206_183507.png" alt="Settings"></a><br>搜索<code>C_Cpp.intelliSenseEngine</code>这个属性，设置值为<code>&quot;Default&quot;</code>。官方说明这个是使用新的智能提示引擎。</p>
<h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><p>添加左侧的虫子图标的<code>Debug</code>Button（或者<code>Ctrl+Shift+D</code>），然后添加配置。<br><a href="/img/2018/02/snipaste_20180206_163956.png"><img src="/img/2018/02/snipaste_20180206_163956.png" alt="Launch"></a><br>选择<code>GDB</code>的。完整文件内容：  </p>
<pre><code>{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/Cpp_vsc.exe&quot;, //main函数所在的文件编译出的exe
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true, //弹出黑乎乎的命令行窗口
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;miDebuggerPath&quot;: &quot;C:/MinGW/bin/gdb.exe&quot;, //gdb的路径
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ],
            &quot;preLaunchTask&quot;: &quot;build&quot;, //build是后边task.json的lable属性
            &quot;targetArchitecture&quot;: &quot;x86_64&quot; //目标架构，可以是x86,x64,arm等
        }
    ]
}
</code></pre><h3 id="task-json"><a href="#task-json" class="headerlink" title="task.json"></a>task.json</h3><p><code>Ctrl+Shift+P</code>输入<code>tasks</code>，选择<code>Configure Task</code><br><a href="/img/2018/02/snipaste_20180206_175001.png"><img src="/img/2018/02/snipaste_20180206_175001.png" alt="Task"></a><br>文件完整内容：</p>
<pre><code>// See https://go.microsoft.com/fwlink/?LinkId=733558
// for the documentation about the tasks.json format
{
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;label&quot;: &quot;build&quot;, //preLaunchTask属性值的来源
            &quot;command&quot;: &quot;g++&quot;, //使用g++编译
            &quot;args&quot;: [
                &quot;-g&quot;,
                &quot;Cpp_vsc.cpp&quot;, //main函数的文件
                &quot;-o&quot;,
                &quot;Cpp_vsc.exe&quot; //输入exe文件名
            ],
            &quot;problemMatcher&quot;: {
                &quot;owner&quot;: &quot;cpp&quot;,
                &quot;fileLocation&quot;: [
                    &quot;relative&quot;,
                    &quot;${workspaceFolder}&quot;
                ],
                &quot;pattern&quot;: {
                    &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;,
                    &quot;file&quot;: 1,
                    &quot;line&quot;: 2,
                    &quot;column&quot;: 3,
                    &quot;severity&quot;: 4,
                    &quot;message&quot;: 5
                }
            }
        }
    ]
}
</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>编写简单的HelloWorld程序测试一下</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main()
{
    std::cout &lt;&lt; &quot;VSC is cool!!!&quot; &lt;&lt; std::endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>按F5运行，正常。<br><a href="/img/2018/02/run.png"><img src="/img/2018/02/run.png" alt="Run"></a></p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> VSC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArchLinux安装gnome桌面]]></title>
      <url>/2018/01/31/archlinux-gnome-install/</url>
      <content type="html"><![CDATA[<h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>在<a href="https://wiki.archlinux.org/index.php/xorg#Driver_installation" target="_blank" rel="external">这里</a>可以找到你的显卡对应的包。我的是Intel的集显，所以我执行这条命令<br><code>$ sudo pacman -S xf86-video-intel</code></p>
<h2 id="安装X"><a href="#安装X" class="headerlink" title="安装X"></a>安装X</h2><p><code>$ sudo pacman -S xorg xorg-xinit xterm xorg-xeyes xorg-xclock</code></p>
<h2 id="安装gnome桌面"><a href="#安装gnome桌面" class="headerlink" title="安装gnome桌面"></a>安装gnome桌面</h2><p>其他桌面请活用搜索引擎。<br><code>$ sudo pacman -S gnome</code><br>因为桌面是用NetworkManager，因此要让它启动并开启自启<br><code>$ sudo systemctl enable NetworkManager</code><br><code>$ sudo systemctl start NetworkManager</code></p>
<h2 id="安装工具栏网络图标"><a href="#安装工具栏网络图标" class="headerlink" title="安装工具栏网络图标"></a>安装工具栏网络图标</h2><p><code>$ sudo pacman -S network-manager-applet</code><br>之后让gdm开启自动然后启动它，这时候就可以看到桌面了<br><code>$ sudo systemctl enable gdm</code><br><code>$ sudo systemctl start gdm</code></p>
<p>桌面安装完了之后可以进行一些<a href="">软件安装(不写了就这样发布吧=。=)</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ArchLinux </tag>
            
            <tag> Linux </tag>
            
            <tag> Gnome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装ArchLinux系统]]></title>
      <url>/2018/01/31/archlinux-install/</url>
      <content type="html"><![CDATA[<p>本来不想写这篇文章的，但是想到我花了挺多的时间在Arch上导致没做到其他什么事情，不写的话觉得对不起自己的产出，也同时方便自己日后重装。<br>本文章主要是针对UEFI启动的，MBR的话有稍许不同，可参考这篇<a href="http://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="external">文章</a>。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>话说Arch的Wiki真是丰富，查Wiki能解决挺多问题了，建议看。</li>
<li>官方的安装Wiki：<a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="external">Installation guide</a></li>
<li>制作一个启动U盘，用<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="external">USBWritter</a>即可。</li>
<li>在Windows的磁盘管理中划分出一块磁盘空间出来，无需格式化。</li>
<li>假设你懂得了如何设置启动顺序/快速启动选择，这里忽略。</li>
<li>vim的基本使用方法</li>
<li>每条命令前都有提示符，<code>#</code>表示root用户下执行，<code>$</code>表示普通用户下执行。</li>
</ul>
<p>启动进入U盘的安装引导后，开始进行下面的安装步骤。</p>
<h2 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h2><p>有线网<br><code># dhcpcd</code><br>无线网<br><code># wifi-menu</code><br>网络连接好了之后可以进行一次网络通畅测试<br><code># ping baidu.com</code><br>确认可以后进行下一步。</p>
<h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><p><code># timedatectl set-ntp true</code>  </p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区用<code>fdisk</code><br>首先<br><code># fdisk -l</code><br>查看一下当前磁盘情况（关注磁盘路径和EFI分区路径（非全新磁盘））。因为这里是建立在Windows已经安装好了的情况下进行的，所以肯定会有一个EFI分区，记住它的路径，或者想建立一个独立的EFI分区也是可以的。如果你的磁盘是新的，那么就还要建立一个GPT分区表。<br><code># fdisk /dev/xxx</code><br>（这里的xxx是指你的磁盘路径，不是分区路径）进入操作界面，然后进行下面的操作。</p>
<h3 id="建立EFI分区"><a href="#建立EFI分区" class="headerlink" title="建立EFI分区"></a>建立EFI分区</h3><p>输入<code>g</code>建立GPT分区表（仅对于新磁盘）。然后输入<code>n</code>建立分区，然后会要求我们输入起止扇区，开始扇区默认就好，结束扇区可以输入一个大小，一般大于100M就好，所以我们输入<code>+200M</code>，这里就划分出来了一个200M大小的分区用作引导。输入<code>t</code>选择新建分区类型，输入<code>1</code>表示要建立EFI分区，输入<code>w</code>使刚才的分区操作生效。在这之前可以输入<code>p</code>来查看分区情况。最后格式化一下新建分区<br><code># mkfs.fat -F 32 /dev/xxxY</code><br>（这里的xxxY是指你的引导分区）。</p>
<h3 id="建立根分区"><a href="#建立根分区" class="headerlink" title="建立根分区"></a>建立根分区</h3><p>这里没有建立其他分区而是直接一个根分区，要是想把Linux其他路径挂在到独立的分区（因为我的是双系统，磁盘空间本来就不够了，懒得再分，如果是要绝心装单系统，那么可以划出更多的分区），那么可以活用搜索引擎了解一下Linux的分区。分区操作是一样，只是在<code>fstab</code>记录分区表的时候会多一点记录。<br><code># fdisk /dev/xxx</code><br>选中磁盘，然后输入<code>n</code>新建分区，因为我想把剩下的空间全部利用上，所以输入起止扇区的时候都直接回车就好了。同样输入<code>w</code>生效，然后格式化分区<br><code># mkfs.ext4 -b 4096 /dev/xxxY</code><br>(这里的xxxY是刚新建的根分区，4096是确保4K对齐)。</p>
<h3 id="挂载根分区"><a href="#挂载根分区" class="headerlink" title="挂载根分区"></a>挂载根分区</h3><p><code># mount /dev/xxxY /mnt（xxxY是根分区）</code><br><code># mkdir /mnt/boot</code><br><code># mount /dev/xxxY /mnt/boot（这里的xxxY是EFI分区）</code></p>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p><code># vim /etc/pacman.d/mirrorlist</code>  </p>
<p>在顶部添加速度会较快一点的源，这里添加了清华大学的源</p>
<blockquote>
<p>Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</a>  </p>
</blockquote>
<p>保存退出。</p>
<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><p><code># pacstrap /mnt base base-devel</code><br>base-devel包含了基本的工具，如sudo，pacman等，具体包含了什么可以在<a href="https://www.archlinux.org/groups/x86_64/base-devel/" target="_blank" rel="external">这里</a>查看。</p>
<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><h3 id="生成fstab"><a href="#生成fstab" class="headerlink" title="生成fstab"></a>生成fstab</h3><p>这个是用来让系统挂载分区时候用的<br><code># genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code><br>这一步很重要，用<br><code># vim /mnt/etc/fstab</code><br>查看生成的文件，有误可以编辑它。</p>
<h3 id="root切换到系统"><a href="#root切换到系统" class="headerlink" title="root切换到系统"></a>root切换到系统</h3><p><code># arch-chroot /mnt</code></p>
<h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><p><code># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code><br><code># hwclock --systohc</code><br>第二条命令是同步硬件时钟为UTC。</p>
<h3 id="安装会用到的软件"><a href="#安装会用到的软件" class="headerlink" title="安装会用到的软件"></a>安装会用到的软件</h3><p>比如vim等<br><code># pacman -S vim dialog wpa_supplicant ntfs-3g networkmanager</code></p>
<h3 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h3><p><code># vim /etc/locale.gen</code><br>然后找到</p>
<blockquote>
<p>zh_CN.UTF-8 UTF-8<br>  zh_HK.UTF-8 UTF-8<br>  zh_TW.UTF-8 UTF-8<br>en_US.UTF-8 UTF-8  </p>
</blockquote>
<p>这四行，去掉注释。接下来运行这条命令<br><code># locale-gen</code><br>然后<br><code># vim /etc/locale.conf</code></p>
<p>在第一行写入  </p>
<blockquote>
<p>LANG=en_US.UTF-8</p>
</blockquote>
<h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p><code># vim /etc/hostname</code></p>
<p>输入你喜欢的主机名（比如我的mcarch）。然后编辑一下hosts文件<br><code># vim /etc/hosts</code></p>
<p>然后在里边输入</p>
<blockquote>
<p>127.0.0.1    localhost<br>::1        localhost<br>127.0.1.1    mcarch.localdomain    mcarch</p>
</blockquote>
<h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><p><code># passwd</code></p>
<h3 id="安装Intel-ucode（农企用户请忽视）"><a href="#安装Intel-ucode（农企用户请忽视）" class="headerlink" title="安装Intel-ucode（农企用户请忽视）"></a>安装Intel-ucode（农企用户请忽视）</h3><p><code># pacman -S intel-ucode</code></p>
<h3 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装Bootloader</h3><p><code># pacman -S os-prober //多系统需要</code><br><code># pacman -S grub efibootmgr</code></p>
<p>部署grub<br><code># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</code></p>
<p>生成配置文件<br><code># grub-mkconfig -o /boot/grub/grub.cfg</code></p>
<p>如果爆出</p>
<blockquote>
<p>warning failed to connect to lvmetad，falling back to device scanning.</p>
</blockquote>
<p>这个药（错）丸（误），简单解决方法是编辑</p>
<blockquote>
<p>/etc/lvm/lvm.conf</p>
</blockquote>
<p>这个文件，找到<code>use_lvmetad = 1</code>这一行，把<code>1</code>改成<code>0</code>即可。</p>
<h3 id="配置Windows的启动入口"><a href="#配置Windows的启动入口" class="headerlink" title="配置Windows的启动入口"></a>配置Windows的启动入口</h3><p>参考<a href="https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_UEFI-GPT_Mode_menu_entry" target="_blank" rel="external">这里</a>，添加到<code>/boot/grub/grub.cfg</code>这个文件中，在<code>Arch Linux</code>这个<code>menuentry</code>前或后添加Windows的<code>menuentry</code></p>
<pre><code>if [ &quot;${grub_platform}&quot; == &quot;efi&quot; ]; then
    menuentry &quot;Windows 10&quot; {
        fs_uuid=CEC0-7D1B
        hints_string=--hint-bios,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=achi0,gpt1
        insmod part_gpt
        insmod fat
        insmod search_fs_uuid
        insmod chain
        search --fs-uuid --set=root $hints_string $fs_uuid
        chainloader /EFI/Microsoft/Boot/bootmgfw.efi
    }
fi
</code></pre><p>fs_uuid这个值是通过这条命令得到的<br><code># grub-probe --target=fs_uuid $esp/EFI/Microsoft/Boot/bootmgfw.efi</code><br>hints_string的值是通过这条命令得到的<br><code># grub-probe --target=hints_string $esp/EFI/Microsoft/Boot/bootmgfw.efi</code><br>如果上边两条命令爆路径错误，直接切换到bootmgfw.efi的路径下<br><code># cd /boot/EFI/Microsoft/Boot</code><br>然后去掉bootmgfw.efi前边的路径执行。比如第一条命令<br><code># grub-probe --target=fs_uuid bootmgfw.efi</code><br>还有可能爆的错是获取hints_string的时候，因为我的SSD是NVMe的，然后爆出了这个错误</p>
<blockquote>
<p>grub-probe: warning: unknown device type nvme0n1.</p>
</blockquote>
<p>我Google了一下并没有找到解决方案[绝望脸.jpg]，于是自己臆测Wiki给出的大概那是单块磁盘的输出，所以我直接就copy了Wiki给出的值。</p>
<blockquote>
<p>–hint-bios=hd0,gpt1 –hint-efi=hd0,gpt1 –hint-baremetal=ahci0,gpt1</p>
</blockquote>
<p>我大概猜测一下<code>hd0</code>是指第1块磁盘，在<code>fdisk -l</code>的输出结果中，我的磁盘是<code>nvme0n1</code>，如果有第二块NVMe磁盘应该就是<code>nvme1n1</code>。如果你只有单块NVMe磁盘，那么这么写是没错的，亲测能正常启动Windows。而我测试了gpt后边的数字写什么都可以启动，如果你有多块磁盘，你也是可以测试一下。欢迎在评论区写下你的结果。;)</p>
<h3 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h3><p><code># adduser -m -G wheel [username]</code><br>设置密码<br><code># passwd [username]</code><br>添加sudo<br><code># vim /etc/sudoers</code><br>找到</p>
<blockquote>
<p># %wheel ALL=(ALL)ALL</p>
</blockquote>
<p>这行，把<code>#</code>去掉，保存退出。</p>
<h3 id="安装yaourt"><a href="#安装yaourt" class="headerlink" title="安装yaourt"></a>安装yaourt</h3><p><code># vim /etc/pacman.conf</code><br>在末尾加上</p>
<blockquote>
<p>[archlinuxcn]<br>SigLevel = Optional TrustAll<br>Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</a></p>
</blockquote>
<p>然后运行<br><code># pacman -Sy yaourt fakeroot</code></p>
<h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p><code># exit</code><br><code># reboot</code><br>ALL DONE！重启后可以用新建的用户登陆，然后联网进行后序的<a href="../archlinux-gnome-install/">桌面安装</a>。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ArchLinux </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次C#爬虫经历]]></title>
      <url>/2018/01/06/crawler/</url>
      <content type="html"><![CDATA[<p>这几天都在写C++，感觉都要吐了（原谅我太渣(/▽＼)），适当写写C#转换一下心情。既然要转换心情，那么就应该有点乐趣，那就把我们学院的所有人的人头照都爬了吧！<br>我校的人头照很好爬，连认证都不用就可以用直链Get到。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>当然要准备一下所有人的花名册，这个不难get到，这学期分专业的时候有excel文件公示，copy，paste，完工。</p>
<h1 id="敲代码"><a href="#敲代码" class="headerlink" title="敲代码"></a>敲代码</h1><p>这里一共准备两个方法即可，一个用来读取文件，获得所有人的学号和姓名，另一个方法负责把这些照片download下来。</p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><pre><code class="CSharp">static Dictionary&lt;string, string&gt; GetInfo()
{
    Dictionary&lt;string, string&gt; dictionary = new Dictionary&lt;string, string&gt;();

    using (StreamReader sr = new StreamReader(&quot;id_names.txt&quot;))
    {
        string line = null;
        while ((line = sr.ReadLine()) != null)
        {
            var words = line.Split(&#39; &#39;);
            dictionary.Add(words[0], words[1]);
        }
    }
    return dictionary;
}
</code></pre>
<p>函数返回一个以学号为Key，姓名为Value的字典，有了这个字典，我们就可以遍历所有的元素然后爬图了。</p>
<h2 id="爬图"><a href="#爬图" class="headerlink" title="爬图"></a>爬图</h2><pre><code class="CSharp">static void PullImage(string url, string id, string name)
{
    string url_ = url + id + &quot;.jpg&quot;;
    HttpWebRequest webRequest = WebRequest.Create(url_) as HttpWebRequest;

    Image img = null;
    try
    {
        var webResponse = webRequest.GetResponse();
        var stream = webResponse.GetResponseStream();
        img = Image.FromStream(stream);
        img.Save($&quot;pics/{id} {name}.jpg&quot;);
    }
    catch (Exception e)
    {
        Console.WriteLine($&quot;Get {name}&#39;s pic with error.&quot;);
        Console.WriteLine(e.Message);
    }
}
</code></pre>
<p>添加异常捕获，不然会因为某个图片获取过程出现错误而导致程序奔掉，后续学生的照片获取中断。  </p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>两个函数都准备好了，那么就开始实验吧！</p>
<pre><code class="CSharp">static void Main(string[] args)
{
    string url = &quot;http://xxx/xxx/photo/student/&quot;; //这里把链接抹掉了

    var ret = GetInfo();
    foreach (var r in ret)
    {
        PullImage(url, r.Key, r.Value);
        Thread.Sleep(1300); //暂停1.3秒，不然可能会因为频繁发送请求服务器方面出现问题（毕竟土豆服务器）
    }

    Console.WriteLine(&quot;Done&quot;);
    Console.ReadLine();

}
</code></pre>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>最后的运行结果如下图，一个学生的照片获取超时了，还行。<br><a href="/img/2018/01/snipaste_20180106_203755.png"><img src="/img/2018/01/snipaste_20180106_203755.png" alt=""></a><br>这下我可以认识认识本学院所有人了(ಥ _ ಥ)</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#委托和事件]]></title>
      <url>/2017/12/11/delegate-event/</url>
      <content type="html"><![CDATA[<p>C#这门语言我是高中开始接触的，当时学得很肤浅，也没有太多的实践，委托的代码从未写过，事件也只有写WPF的时候用到控件自带的事件。几年后的今天我觉得如此优雅的一门语言时候后要重拾了，重新审视一遍委托和事件后觉得豁然开朗。</p>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>之前我看委托很是不理解它存在的意义，现在学习C++后知道了函数指针这么一个东西并且用过后才理解了委托，现在想想委托这么一个名字取得也是很形象呢！《C#图解教程》[第4版]这本书上也写了：如果你有C++背景，理解委托最快的方法是把它看成一个类型安全的、面向对象的C++函数指针。</p>
<p>先看启蒙我的C++的函数指针。很常见的一个方法就是algorithm里的sort方法，它需要一个函数指针作为参数。</p>
<pre><code class="Cpp">std::sort(_vec.begin(), _vec.end(), compare);
</code></pre>
<p>最后一个函数的定义是这样的</p>
<pre><code class="Cpp">bool compare(int x, int y) { return x &amp;lt; y; }
</code></pre>
<p>这样就完成了对_vec这个向量的排序，可以看到这里把函数作为参数传进了另外一函数方法里被使用。C#里的委托就实现了相同的功能，而且被设计得更强大，有了委托，我们甚至可以把一组方法传进另一个方法里。</p>
<p>那么我们看看C#里是如何实现这样的功能的吧。现在我们需要传进的方法的功能是对两个实数进行某种操作，然后把得到的结果返回。首先我们先定义一个委托类型</p>
<pre><code class="CSharp">delegate double MathOperation(double x, double y);
</code></pre>
<p>然后我们定义类型匹配的方法</p>
<pre><code class="CSharp">public static double Add(double x, double y) { return x + y; }
</code></pre>
<p>接着我们定义这么一个方法</p>
<pre><code class="CSharp">public static void HandleTwoNum(double x, double y, MathOperation operation)
{
    double ret = operation(x, y);
    Console.WriteLine(ret);
}
</code></pre>
<p>实现了对两个实数进行相加的操作然后把得到的结果显示出来，而这个[操作]正是通过委托来进行传递的。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>当年学委托和事件总是傻傻分不清楚，总觉得这两货就是一个东西。其实本质上来说它俩真的就是如此相近的东西！想想吧，我们要弄一个事件出来还得先定义一个委托呢。但是事件基于委托而又显著区别与委托的是什么呢？为什么要弄出事件这么一个东西呢？现在想想不过是微软想弄事件驱动这么一套机制罢了，形成发布者-订阅者的关系，订阅者提供事件处理程序，发布者触发事件。事件普遍存在WinForm和WPF中。</p>
<p>先定义一个委托</p>
<pre><code class="CSharp">delegate void MyEventHandler();
</code></pre>
<p>定义事件发布者</p>
<pre><code class="CSharp">class Publisher
{
    public event MyEventHandler Handler;
    public void Invoke()
    {
        Handler();
    }
}
</code></pre>
<p>需要注意的是事件只能在发布者里被触发，即使声明为public可以在类外部添加事件处理函数。</p>
<p>然后就是订阅者</p>
<pre><code class="CSharp">class Subcriber
{
    public void MyEventHandler()
    {
        Console.WriteLine(&quot;Subcriber&quot;);
    }
    public Subcriber(Publisher publisher)
    {
        publisher.Handler += MyEventHandler;
    }
}
</code></pre>
<p>最后触发事件</p>
<pre><code class="CSharp">Publisher publisher = new Publisher();
Subcriber subcriber = new Subcriber(publisher);
publisher.Invoke();
</code></pre>
<p>如果我不用事件仅仅用委托可不可实现这么以上的关系呢？当然可以，看代码</p>
<pre><code class="CSharp">delegate void MyEventHandler();
class FakePublisher
{
    public MyEventHandler Handler;
    public void Invoke()
    {
        Handler();
    }
}
class Subcriber
{
    public void MyEventHandler()
    {
        Console.WriteLine(&quot;Subcriber&quot;);
    }
    public Subcriber(FakePublisher publisher)
    {
        publisher.Handler += MyEventHandler;
    }
}
</code></pre>
<p>触发[Fake]事件</p>
<pre><code class="CSharp">FakePublisher publisher = new FakePublisher();
Subcriber subcriber = new Subcriber(publisher);
publisher.Invoke();
//publisher.Handler();
</code></pre>
<p>这里我们不仅可以通过Invoke方法触发[Fake]事件，更是可以直接通过委托触发。这里体现出来事件发布者来管理事件的触发这个理念。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>以上就是我对委托和事件的心得，希望对正在学习的你有所帮助（￣︶￣）↗</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON in .NET(C#)]]></title>
      <url>/2017/09/20/json-in-dotnet/</url>
      <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation) is popularly used nowadays. For JavaScript, it’s easy to convert a object to json. How about C#? How do we get some properties we need from a json typed object? And how do we convert our object into json formatted text? This article aims to solve the problems. You will see it can be convenient to solve the problems<strong><em>.(●’◡’●)</em></strong></p>
<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>There is one thing we need to do before start. That is installing the a NuGet package named <em><strong>JSON.NET</strong></em>. In Visual Studio, we can search any package and install it easily. Search <em><strong>JSON.NET</strong></em>, then install it to you project.</p>
<p><a href="/img/2017/09/snipaste_20170920_201049.png"><img src="/img/2017/09/snipaste_20170920_201049.png" alt="snipaste_20170920_201049"></a></p>
<h1 id="Serialization-and-Deserialization"><a href="#Serialization-and-Deserialization" class="headerlink" title="Serialization and Deserialization"></a>Serialization and Deserialization</h1><p>These operations are suitable for the definitive type we know or define. For example, we now have a class named <strong>Rectangle.</strong></p>
<pre><code class="CSharp">class Rectangle
{
    public int Height { get; set; }
    public int Width { get; set; }
    private Rectangle() { }
    public Rectangle(int height,int width)
    {
        Height = height;
        Width = width;
    }
}
</code></pre>
<p>Then we need to refer one namespace.</p>
<p><code>using Newtonsoft.Json;</code></p>
<p>After that, we can use class <strong>JsonConvert</strong> to serialize a Rectangle typed object or a list of Rectangle typed objects. Code as follow.</p>
<pre><code class="CSharp">List list = new List();
list.Add(new Rectangle(1, 2));
list.Add(new Rectangle(45, 23));
string json = JsonConvert.SerializeObject(list);
</code></pre>
<p>If we print variable <code>json</code> to the console window, we can see the result as this.</p>
<p><a href="/img/2017/09/snipaste_20170920_204618.png"><img src="/img/2017/09/snipaste_20170920_204618.png" alt="snipaste_20170920_204618"></a></p>
<p>How about deserialize object(s) from a json formatted text? Much easy! Only one line code!</p>
<pre><code class="CSharp">var objs = JsonConvert.DeserializeObject&lt;List&lt;Rectangle&gt;&gt;(json);
</code></pre>
<p>You may doubt whether it’s correct. Well, let’s verify that. Write some code as follow.</p>
<pre><code class="CSharp">for (int i = 0; i &amp;lt; objs.Count; i++)
{
    Console.WriteLine($&quot;{i + 1}th object info:&quot;
        + $&quot;Height:{objs[i].Height} Width:{objs[i].Width}&quot;);
}
</code></pre>
<p>We will get the result.</p>
<p><a href="/img/2017/09/snipaste_20170920_205856.png"><img src="/img/2017/09/snipaste_20170920_205856.png" alt="snipaste_20170920_205856"></a></p>
<p><strong>Correct! Congratulation!</strong></p>
<h1 id="Pick-Properties-from-JSON"><a href="#Pick-Properties-from-JSON" class="headerlink" title="Pick Properties from JSON"></a>Pick Properties from JSON</h1><p>Consider one situation, we get some JSON typed text from any way like API. One problem we will face is that we don’t have a exact type for that. Thus, we can’t deserialize it to a exact typed object. Thanks to JSON.NET this powerful library, we can continue to work in such situation without too much code. Let’s figure out!</p>
<p>Firstly, get json formatted text via API.</p>
<pre><code class="CSharp">HttpWebRequest request = (HttpWebRequest)WebRequest.Create(@&quot;http://samples.openweathermap.org/data/2.5/weather?q=London,uk&amp;amp;appid=b1b15e88fa797225412429c1c50c122a1&quot;);
request.Method = &quot;GET&quot;;
request.ContentType = &quot;text/json&quot;;
var response = request.GetResponse();
string json = string.Empty;
using (StreamReader sr = new StreamReader(response.GetResponseStream()))
{
    json = sr.ReadToEnd();
}
</code></pre>
<p>If we print variable <code>json</code> out, we will see this.</p>
<p><a href="/img/2017/09/snipaste_20170920_210725.png"><img src="/img/2017/09/snipaste_20170920_210725.png" alt="snipaste_20170920_210725"></a></p>
<p>If we want to get wind speed, we can write this code.</p>
<pre><code class="CSharp">JToken token = JObject.Parse(json);
string speed = (string)token.SelectToken(&quot;wind&quot;).SelectToken(&quot;speed&quot;);
</code></pre>
<p>The variable speed is the result we want. Not complicated.</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>(￣y▽￣)╭ Ohohoho…..</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> C# </tag>
            
            <tag> JSON </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Windows新增右键菜单项]]></title>
      <url>/2017/07/17/add-right-click-menu/</url>
      <content type="html"><![CDATA[<p>Windows中，除了系统自带的一些右键菜单项之外，在一些时候我们安装软件后可以发现在右键菜单新增了一些软件的相关右键菜单项，就像这样</p>
<p><a href="/img/2017/07/snipaste_20170717_223144.png"><img src="/img/2017/07/snipaste_20170717_223144.png" alt=""></a></p>
<p>Ok，那么我们想自己也弄一个怎么办呢？下面开始正片，<span style="font-weight: bold; color: #d14;">友情提醒：本文会涉及到修改注册表，请备份好原注册表后再修改。</span></p>
<h2 id="打开注册表"><a href="#打开注册表" class="headerlink" title="打开注册表"></a>打开注册表</h2><p>Win+R运行regedit</p>
<p><a href="/img/2017/07/snipaste_20170717_224739.png"><img src="/img/2017/07/snipaste_20170717_224739.png" alt=""></a></p>
<p>找到该路径：<br><code>HKEY_CLASSES_ROOT\Directory\Background\shell</code></p>
<h2 id="增添新项"><a href="#增添新项" class="headerlink" title="增添新项"></a>增添新项</h2><p>选中<code>shell</code>然后右键<code>New</code>-&gt;<code>Key</code>新建一个项，如图</p>
<p><a href="/img/2017/07/snipaste_20170717_225314.png"><img src="/img/2017/07/snipaste_20170717_225314.png" alt=""></a></p>
<p>我命名为Cmder，在新建的<code>Cmder</code>项下在新建一个项，命名为<code>command</code>，然后修改其下默认键的值为要运行程序的路径。比如我的</p>
<p><a href="/img/2017/07/snipaste_20170717_230121.png"><img src="/img/2017/07/snipaste_20170717_230121.png" alt=""></a></p>
<p>然后在资源管理器空白处点击右键时就会发现了这个选项，但是有点丑陋，我们来稍微地美化一下，给添加的右键菜单增加图标和描述信息。</p>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>选中<code>Cmder</code>，接着在右侧中新建几个<code>string</code>类型的值。</p>
<p><a href="/img/2017/07/snipaste_20170717_230807.png"><img src="/img/2017/07/snipaste_20170717_230807.png" alt=""></a></p>
<p>新增两个值，分别为</p>
<p><a href="/img/2017/07/snipaste_20170717_230940.png"><img src="/img/2017/07/snipaste_20170717_230940.png" alt=""></a></p>
<p><code>Icon</code>用来给菜单添加一个小图标，<code>MUIVerb</code>用来给菜单添加描述信息。完成后再查看一下就会是这个效果</p>
<p><a href="/img/2017/07/snipaste_20170717_231530.png"><img src="/img/2017/07/snipaste_20170717_231530.png" alt=""></a></p>
<p>测试一下，完美运行。</p>
<h2 id="增加子菜单项"><a href="#增加子菜单项" class="headerlink" title="增加子菜单项"></a>增加子菜单项</h2><p>正如第一张图所示，还应该有子菜单项才足够满足一些需求，这都不是事。</p>
<p>首先，我们回到<code>Cmder</code>项下，再添加一个<code>string</code>类型的值，名字为<code>SubCommands</code>，然后值的内容填写你想要添加的命令的名字（千万避免重复），每个命令之间用半角分号<code>;</code>隔开，就像这样</p>
<p><a href="/img/2017/07/snipaste_20170717_232103.png"><img src="/img/2017/07/snipaste_20170717_232103.png" alt=""></a></p>
<p>还没完，这时候你可以再查看右键菜单的时候可以看到刚才添加的菜单项已经有个右尖括号了，但是因为具体的子命令还没实现，所以不会显现出来。这个时候我们定位到<code>Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell</code>下，然后再新建新项，名字为刚才加入的子命令名字，比如我的</p>
<p><a href="/img/2017/07/snipaste_20170717_232828.png"><img src="/img/2017/07/snipaste_20170717_232828.png" alt=""></a></p>
<p>接下来的操作就和上边的一毛一样了。</p>
<p>最后的效果就是这样</p>
<p><a href="/img/2017/07/snipaste_20170717_222321.png"><img src="/img/2017/07/snipaste_20170717_222321.png" alt=""></a></p>
<h2 id="Shift-右键"><a href="#Shift-右键" class="headerlink" title="Shift+右键"></a>Shift+右键</h2><p>还有一些菜单项是通过Shift+鼠标右组合键才会显现出来的，要实现这个也很简单，只需要添加一个新值<code>Extended</code>即可。</p>
<p><a href="/img/2017/07/snipaste_20170817_115734.png"><img src="/img/2017/07/snipaste_20170817_115734.png" alt=""></a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Windows 10 </tag>
            
            <tag> Windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义run命令]]></title>
      <url>/2017/06/11/runplus/</url>
      <content type="html"><![CDATA[<p>相信各位都会有过这样的操作，Win+R-&gt;输入要运行的程序-&gt;确定。 譬如经常会用到的命令行</p>
<p><a href="/img/2017/06/snipaste_20170611_181819.png"><img src="/img/2017/06/snipaste_20170611_181819.png" alt=""></a></p>
<p>现在我想自己添加一个，怎么办呢？我们知道，运行这个程序是在环境变量查找符合名称的程序然后运行它的，依照这个思路笔者在这里介绍一种解决方案。</p>
<p>首先，在随便一个目录下新建一个文件夹，你喜欢就好。</p>
<p><a href="/img/2017/06/snipaste_20170611_181750.png"><img src="/img/2017/06/snipaste_20170611_181750.png" alt=""></a></p>
<p>然后在控制面板中设置一下环境变量。</p>
<p><a href="/img/2017/06/Untitled.png"><img src="/img/2017/06/Untitled.png" alt=""></a></p>
<p>新建一个环境变量，然后把刚才新建的目录路径复制进去。</p>
<p>我们把需要运行的程序新建一个快捷方式，名称你喜欢，方便你自己就好，丢到目录下。</p>
<p><a href="/img/2017/06/snipaste_20170611_184550.png"><img src="/img/2017/06/snipaste_20170611_184550.png" alt=""></a></p>
<p>最后你在运行里输入对应的快捷方式的名称，然后就是见证奇迹的时刻。</p>
<p><a href="/img/2017/06/snipaste_20170611_194951.png"><img src="/img/2017/06/snipaste_20170611_194951.png" alt=""></a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[揪出Windows Spotlight壁纸]]></title>
      <url>/2017/04/06/get-windows-spotlight-wallpaper/</url>
      <content type="html"><![CDATA[<!-- # <span style="color: #ff6600;">**这是一篇无聊的水文！**</span>

# <span style="color: #ff6600;">**这是一篇无聊的水文！**</span>

# <span style="color: #ff6600;">**这是一篇无聊的水文！**</span> -->
<p>Windows 10的Spotlight偶尔会推荐个人比较喜欢的锁屏壁纸，这时候如果我们想得到图片文件该怎么办？比如这张，笔者个人觉得挺魔幻的。</p>
<p><a href="/img/2017/04/sp170406_120203.png"><img src="/img/2017/04/sp170406_120203.png" alt=""></a></p>
<h2 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h2><p>在Windows Explorer进入该路径</p>
<pre><code>C:\Users\[User Name]\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets
</code></pre><p>在该目录下可以看到一些没有扩展名的文件，这些其实就是图片文件，如图</p>
<p><a href="/img/2017/04/sp170406_121024.png"><img src="/img/2017/04/sp170406_121024.png" alt=""></a></p>
<h2 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h2><p>将上图目录下的所有文件复制到任意目录下，我在桌面上新建了一个名为New Folder的文件夹然后全部丢进去。</p>
<h2 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h2><p>然后正片开始，网上很多都是直接用cmd修改文件名添加扩展名，这里装逼地用了PowerShell。我会给每个图片一个位宽为3的序号并添加扩展名。</p>
<p>先定义一个序号的变量</p>
<pre><code class="PowerShell">$index=1
</code></pre>
<p>然后修改图片文件文件名</p>
<pre><code class="PowerShell">Get-ChildItem|foreach{Rename-Item -Path $_.FullName -NewName (&#39;pic_{0:d3}.jpg&#39; -f $index);$index++}
</code></pre>
<p><a href="/img/2017/04/sp170406_121955-1.png"><img src="/img/2017/04/sp170406_121955-1.png" alt=""></a><br>这时候再看看文件夹，所有文件都已经显示为图片格式文件了。ALL DONE！</p>
<p><a href="/img/2017/04/sp170406_182143.png"><img src="/img/2017/04/sp170406_182143.png" alt=""></a></p>
<p>这里准备了整个脚本（图片保存在桌面的spotlight文件夹内），保存为ps1直接运行即可（记得修改PowerShell的ExecutionPolicy）：<a href="/static/spotlight.ps1">点这里</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binding[3]=MultiBinding]]></title>
      <url>/2017/02/14/binding-multibinding/</url>
      <content type="html"><![CDATA[<p>有时候，我们会遇到这样的需求，UI的要显示的信息由多个数据源来决定，比如注册界面会验证两次输入的密码是否一致来决定是否可以注册，这时候就要用到MultiBinding了。因为Binding和MultiBinding的基类都是BindingBase，所以，能用Binding的场合都能用MultiBinding。MultiBinding通过一个Bindings的属性（类型为Collection<bindingbase>）把多个Binding对象集合起来，其中每个Binding对象可以有自己的数据校验和数据转换机制。</bindingbase></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们就以注册界面为例，需求是，用户名和密码都不会为空，且两次输入的密码要一致，这时候确认信息的Button可用。XAML代码如下，加入了一些部分美化的代码，默认的太难看了受不了- -，主要的就是三个TextBox。</p>
<pre><code class="XML">&lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;
    &lt;TextBlock Text=&quot;Sign up&quot; FontSize=&quot;30&quot; Foreground=&quot;#00a2e8&quot; Margin=&quot;3&quot;/&gt;
    &lt;TextBlock Text=&quot;User&quot; FontSize=&quot;13&quot; Margin=&quot;3&quot;/&gt;
    &lt;TextBox x:Name=&quot;textBox&quot; Height=&quot;23&quot; Width=&quot;150&quot; Margin=&quot;3&quot;/&gt;
    &lt;TextBlock Text=&quot;Password&quot; Margin=&quot;5&quot;/&gt;
    &lt;TextBox x:Name=&quot;textBox1&quot; Height=&quot;23&quot; Width=&quot;150&quot; Margin=&quot;3&quot;/&gt;
    &lt;TextBlock Text=&quot;Verify Password&quot; Margin=&quot;5&quot;/&gt;
    &lt;TextBox x:Name=&quot;textBox2&quot; Height=&quot;23&quot; Width=&quot;150&quot; Margin=&quot;3&quot;/&gt;
    &lt;Button x:Name=&quot;button&quot; Height=&quot;23&quot; Margin=&quot;3&quot;&gt;
        &lt;Button.Style&gt;
            &lt;Style TargetType=&quot;Button&quot;&gt;
                &lt;Setter Property=&quot;Template&quot;&gt;
                    &lt;Setter.Value&gt;
                        &lt;ControlTemplate TargetType=&quot;Button&quot;&gt;
                            &lt;Border x:Name=&quot;border&quot; Background=&quot;#00a2e8&quot;&gt;
                                &lt;TextBlock x:Name=&quot;textBlock&quot; Text=&quot;OK&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot;/&gt;
                            &lt;/Border&gt;
                            &lt;ControlTemplate.Triggers&gt;
                                &lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;False&quot;&gt;
                                    &lt;Setter TargetName=&quot;border&quot; Property=&quot;Background&quot; Value=&quot;LightGray&quot;/&gt;
                                &lt;/Trigger&gt;
                            &lt;/ControlTemplate.Triggers&gt;
                        &lt;/ControlTemplate&gt;
                    &lt;/Setter.Value&gt;
                &lt;/Setter&gt;
            &lt;/Style&gt;
        &lt;/Button.Style&gt;
    &lt;/Button&gt;
&lt;/StackPanel&gt;
</code></pre>
<p>三个TextBox会各自作为三个Binding对象的Source，最终把三个Binding对象加入MultiBinding的Bindings属性中。</p>
<pre><code class="CSharp">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        this.SetMultiBinding();
    }

    private void SetMultiBinding()
    {
        Binding b0 = new Binding(&quot;Text&quot;) { Source = this.textBox };
        Binding b1 = new Binding(&quot;Text&quot;) { Source = this.textBox1 };
        Binding b2 = new Binding(&quot;Text&quot;) { Source = this.textBox2 };

        MultiBinding mb = new MultiBinding();
        mb.Bindings.Add(b0);
        mb.Bindings.Add(b1);
        mb.Bindings.Add(b2);
        mb.Converter = new MultiBindingConverter();

        this.button.SetBinding(Button.IsEnabledProperty, mb);
    }
}
</code></pre>
<p>因为Text和IsEnabled两个属性类型不同，因此我们要给MutilBinding准备一个转换器，这个类继承于IMultiValueConverter接口。</p>
<pre><code class="CSharp">class MultiBindingConverter : IMultiValueConverter
{
    public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
    {
        if (!values.Cast&lt;string&gt;().Any(text =&gt; string.IsNullOrWhiteSpace(text)) 
            &amp;&amp; values[1].ToString() == values[2].ToString())
        {
            return true;
        }
        return false;
    }

    public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>运行的效果</p>
<table>
<thead>
<tr>
<th style="text-align:center">Not OK</th>
<th style="text-align:center">OK</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="/img/2017/02/sp170214_210649.png"><img src="/img/2017/02/sp170214_210649.png" alt=""></a></td>
<td style="text-align:center"><a href="/img/2017/02/sp170214_210735.png"><img src="/img/2017/02/sp170214_210735.png" alt=""></a></td>
</tr>
</tbody>
</table>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Q：看了下转换器的代码，其中的values参数应该是指多个Binding对象的Path属性值，那么怎样知道哪个value是哪个Binding对象的呢？</p>
<p>A：我们说过，Bindings属性是个集合，在把Binding对象丢进去的时候是按顺序递增索引的，因此只要记住顺序，就可以通过索引得到对应的value。</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WordPress迁移-Windows Server 2012到Centos 7]]></title>
      <url>/2017/02/13/wordpress-migration/</url>
      <content type="html"><![CDATA[<p>买了VPS顺便试着把博客迁移到国外去，实际操作了过后自我感觉WordPress的迁移其实不难。</p>
<h2 id="准备工作-环境搭建"><a href="#准备工作-环境搭建" class="headerlink" title="准备工作-环境搭建"></a>准备工作-环境搭建</h2><p>在Centos服务器端，我们要先把运行环境搭建好。我选择的是LAMP（Linux+Apache+MySQL+PHP）</p>
<h3 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h3><p><code># yum install httpd</code><br>这样我们就算安装好啦，然后我们就可以将其启动<br><code># systemctl start httpd</code><br>接下来可以在浏览器中输入服务器的IP来检查Apache是否正常开启和运行<br><a href="/img/2017/02/sp170212_132228.png"><img src="/img/2017/02/sp170212_132228.png" alt=""></a><br>这是正常运行的结果，然后我们把Apache设置为开机自启<br><code># systemctl enable httpd</code></p>
<h3 id="安装MySQL-MariaDB"><a href="#安装MySQL-MariaDB" class="headerlink" title="安装MySQL(MariaDB)"></a>安装MySQL(MariaDB)</h3><p><code># yum install mariadb-server mariadb</code><br>安装完成后启动数据库<br><code># systemctl start mariadb</code><br>然后安装一个数据库安全脚本，去掉一些危险的默认设置<br><code># mysql_secure_installation</code><br>接下来会提示你是新安装的，直接按下Enter键，然后设置数据库密码。把MariaDB也设置为开机自启<br><code># systemctl enable mariadb</code></p>
<h3 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h3><p>运行以下命令安装PHP<br><code># yum install php php-mysql</code><br>安装完成之后我们再把Apahce重启一下<br><code># systemctl restart httpd</code><br>接下来我们检查一下PHP是否正常运行，在/var/www/html目录下新建一个info.php文件<br><code># vim /var/www/html/info.php</code><br>内容写入IP<br><code>&lt;?php phpinfo();?&gt;</code><br>然后在浏览器中输入<br><code>xxx.xxx.xxx.xxx/info.php</code><br>xxx代表你的IP地址<br><a href="/img/2017/02/sp170212_133114.png"><img src="/img/2017/02/sp170212_133114.png" alt=""></a></p>
<h3 id="安装phpMyAdmin（可选）"><a href="#安装phpMyAdmin（可选）" class="headerlink" title="安装phpMyAdmin（可选）"></a>安装phpMyAdmin（可选）</h3><p>这是一个数据库管理的Web界面程序，有时候图形化操作还是方便一点的。首先，我们要先安装epel库<br><code># yum install epel-release</code><br>然后我们就可以安装phpMyAdmin了<br><code># yum install phpmyadmin</code><br>安装完成后我们要设置一下权限，不然访问会返回403错误<br><code># vim /etc/httpd/conf.d/phpMyAdmin.conf</code><br>找到这部分并修改为如下  </p>
<pre><code class="XML"> &lt;Directory /usr/share/phpMyAdmin/&gt;
   AddDefaultCharset UTF-8
   &lt;IfModule mod_authz_core.c&gt;
     # Apache 2.4
     &lt;RequireAny&gt;
       #Require ip 127.0.0.1
       #Require ip ::1
        Require all granted
      &lt;/RequireAny&gt;;
   &lt;/IfModule&gt;;
   &lt;IfModule !mod_authz_core.c&gt;;
     # Apache 2.2
     Order Deny,Allow
    # Deny from All
    # Allow from 127.0.0.1
    # Allow from ::1
      Allow from All
   &lt;/IfModule&gt;;
 &lt;/Directory&gt;;
</code></pre>
<p>完了之后再一次重启Apache，然后我们可以在浏览器中输入：<br><code>xxx.xxx.xxx.xxx/phpmyadmin</code><br>来管理数据库<br><a href="/img/2017/02/sp170212_133728.png"><img src="/img/2017/02/sp170212_133728.png" alt=""></a></p>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><h3 id="Windows端"><a href="#Windows端" class="headerlink" title="Windows端"></a>Windows端</h3><p>如果还记得数据库的名称就直接导出，如果不记得了可以先查看一下所有的数据库。<br><code>show databases;</code><br>注意别忘了最后那里有个分号！<br><a href="/img/2017/02/sp170213_110716.png"><img src="/img/2017/02/sp170213_110716.png" alt=""></a><br>找到MySQL的安装目录，找到mysqldump.exe，然后管理员运行cmd，切换到所在目录，执行这个命令<br><code>mysqldump -uroot -p databaseName&gt;outputFileName.sql</code><br>在所在目录下找到生成的数据库，再把wordpress整个文件夹打包一起运回本地就可以了，Windows端的工作完成！</p>
<h3 id="Centos端"><a href="#Centos端" class="headerlink" title="Centos端"></a>Centos端</h3><p>用SSH客户端连接上服务器，用FTP工具把数据库文件和打包文件上传，我都丢到了/var/www/html目录下</p>
<p><a href="/img/2017/02/sp170213_111845.png"><img src="/img/2017/02/sp170213_111845.png" alt=""></a></p>
<p>然后我们就开始着手把数据库导入了，运行<br><code>mysql -uroot -p</code><br>然后输入密码，新建一个数据库<br><code>create database databaseName</code><br>选中新建的数据库<br><code>use databaseName</code><br>导入数据，以我的数据库文件所在目录为例<br><code>source /var/www/html/wordpress_db.sql</code><br>数据库迁移成功后输入exit退出，接下来我们把wordpress实体迁移，直接把压缩文件的内容解压到default目录下即可<br><a href="/img/2017/02/sp170213_113104.png"><img src="/img/2017/02/sp170213_113104.png" alt=""></a></p>
<p>如果你的数据库密码不一样了，修改一下wp-config文件。<br>这时候在浏览器中输入IP/域名试着访问博客，如果之前没有域名的小伙伴就会遇到问题了，比如我- -，那是因为之前的IP地址和现在不同了，数据库中的数据还没更新<br><a href="/img/2017/02/sp170213_113354.png"><img src="/img/2017/02/sp170213_113354.png" alt=""></a><br>就是这里的设置的问题！解决方法就是在数据库中修改这两个值，指向新的IP地址或者你的域名，还记得安装的phpMyAdmin嘛，现在排上用场了<br><a href="/img/2017/02/sp170213_113944.png"><img src="/img/2017/02/sp170213_113944.png" alt=""></a><br>修改两个值就可以了，这时候就可以正常登陆了。<br>然后我们在主页点开文章会出现403错误，调整一下Apache配置文件<br><code># vim /etc/httpd/conf/httpd.conf</code><br>在文件中加入<br><code>LoadModule rewrite_module modules/mod_rewrite.so</code><br>位置随意，下图作为参考<br><a href="/img/2017/02/sp170213_114433.png"><img src="/img/2017/02/sp170213_114433.png" alt=""></a></p>
<p>然后我们再修改一点内容</p>
<pre><code class="XML">&lt;VirtualHost *:80&gt;

ServerName localhost

DocumentRoot /var/www/html/default

&lt;Directory “/var/www/html/default”&gt;

Options FollowSymLinks

AllowOverride ALL

Order allow,deny

Allow from all

&lt;/Directory&gt;

&lt;/VirtualHost&gt;
</code></pre>
<p>把<em>AllowOverride</em>的值换成了<em>ALL，</em>位置如下<br><a href="/img/2017/02/sp170213_114405.png"><img src="/img/2017/02/sp170213_114405.png" alt=""></a><br>保存文件退出，重启Apache。最后再新建一个.htaccess文件，丢到博客根目录下就行了，由于这个文件的文件名有点特殊，要借助其他编辑工具生成，比如笔者用的Visual Studio Code。文件内容如下</p>
<pre><code class="XML">&lt;IfModule mod_rewrite.c&gt;

RewriteEngine On

RewriteBase /

RewriteRule ^index.php$ - [L]

RewriteCond %{REQUEST_FILENAME} !-f

RewriteCond %{REQUEST_FILENAME} !-d

RewriteRule . /index.php [L]

&lt;/IfModule&gt;
</code></pre>
<p>这时候再点击文章就可以正常访问了。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>自此，迁移工作算是完成了，不过还有些小问题，不如文件的上传，下篇文章再讲啦！</p>
<p>本文参考了两位dalao的文章，特别感谢！<br><a href="http://blog.gclxry.com/install-wordpress-on-centos7/" target="_blank" rel="external">Centos 7上安装Wordpress</a><br><a href="https://www.yanning.wang/archives/192.html" target="_blank" rel="external">WordPress跨平台迁移实战</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS-Centos 7搭建配置Shadowsocks科学上网]]></title>
      <url>/2017/02/11/vps-centos-7-shadowsocks/</url>
      <content type="html"><![CDATA[<p>刚刚入手了一个VPS，拿来练手Linux类系统，最重要的还是顺便自己搭建SS科学上网。我这里的是Centos 7 64位。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code># yum install python-setuptools &amp;&amp; easy_install pip</code><br><code># pip install shadowsocks</code><br>这样SS就安装好啦，然后我们要配置一下。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>新建一个json文件<br><code># vim /etc/shadowsocks.json</code><br>然后写入配置，端口和密码自己自定义。</p>
<pre><code class="JSON">{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;server_port&quot;:8900,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;passwd&quot;,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
}
</code></pre>
<p>如果要多用户登陆，那么就把password改成port_password然后加入多个端口和密码，例如：  </p>
<pre><code class="JSON">{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;local_address&quot;:&quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;port_password&quot;:{
         &quot;8900&quot;:&quot;passwd0&quot;,
         &quot;8901&quot;:&quot;passwd1&quot;,
         &quot;8902&quot;:&quot;passwd2&quot;,
         &quot;8903&quot;:&quot;passwd3&quot;,
         &quot;8904&quot;:&quot;passwd4&quot;
    },
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
&gt;
</code></pre>
<p>然后新建一个ss服务<br><code># vim /etc/systemd/system/shadowsocks.service</code><br>内容写入：  </p>
<pre><code>[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json

[Install]
WantedBy=multi-user.target
</code></pre><p>然后开启服务，并让服务开机启动<br><code># systemctl enable shadowsocks</code><br><code># systemctl start shadowsocks</code><br>这时候可以检查一下服务是否正确开启<br><code># systemctl status shadowsocks</code><br>如果Active那里显示的是绿色的active(running)则说明服务正确开启了。如图：<br><a href="/img/2017/02/sp170211_224944.png"><img src="/img/2017/02/sp170211_224944.png" alt=""></a></p>
<p>最后，千万记得防火墙开启刚才配置里写的端口，我的例子里写的只有一个8900，防火墙没开的请自动忽略。<br><code># firewall-cmd --add-port=8900/tcp</code><br>查看端口是否正确开启<br><code># firewall-cmd --query-port=8900/tcp</code><br>返回success则正确开启了，Enjoy it！</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binding[2]=数据转换]]></title>
      <url>/2017/02/09/binding-dataconvert/</url>
      <content type="html"><![CDATA[<p>上一篇文章中我们了解了如何在Binding的过程中对数据进行校验，确保数据的有效性，并且提到了数据类型转换。我们都知道C#是强类型语言，在绑定的过程中，Target和Source的属性类型不同的情况经常遇到，这时候我们就需要手动进行数据类型的转换了。或许有的小伙伴会提出这样一个问题，上一篇文章中的Slider的Value属性是double类型的，TextBox的Text属性是string类型的，也不见对它们进行了数据转换啊！这个是因为，string和double之间的转换比较简单，WPF类库已经帮我们解决这个问题了，但是当我们遇到更加复杂的业务逻辑的时候，我们只能自己写代码了。要实现数据转换其实很简单，只要写一个类继承IValueConverter接口实现Convert和ConvertBack方法，然后在Binding对象中消费这个类就可以了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们的业务是，一个CheckBox并带有提示文字，问用户是不是小基佬，如果是就在下面显示一个动漫可爱女孩子的图片(●’◡’●)，如果不是就显示一个真叫人头大的图片。图片显示用一个Image对象，我们要让它显示出图片内容，就要为它的Source属性赋值，这是ImageSource类型，赋值的时候给一段图片的URI字符串就可以了，而CheckBox的IsChecked是bool类型，因此我们要手写一个转换器。</p>
<pre><code class="CSharp">class CheckBoxStateToImageSourceConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object paremeter, CultureInfo culture)
    {
        if ((bool)value)
        {
            return @&quot;/Assets/bigHead.jpg&quot;;
        }
        return @&quot;/Assets/milai.png&quot;;
    }
    public object ConvertBack(object value, Type targetType, object paremeter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>然后我们要消费这个转换器，只需要给Binding对象的Converter属性赋值一个我们刚刚写的转换器的实例就可以了，XAML代码如下：</p>
<pre><code class="XML">&lt;StackPanel&gt;
    &lt;StackPanel.Resources&gt;
        &lt;local:CheckBoxStateToImageSourceConverter x:Key=&quot;converter&quot;&gt;
    &lt;/StackPanel.Resources&gt;
    &lt;Grid Margin=&quot;10&quot;&gt;
        &lt;CheckBox x:Name=&quot;checkBox&quot;
                HorizontalAlignment=&quot;Left&quot;
                VerticalAlignment=&quot;Center&quot;&gt;;
        &lt;TextBlock Text=&quot;你是基佬嘛？&quot;
                FontSize=&quot;20&quot;
                HorizontalAlignment=&quot;Left&quot;
                Margin=&quot;20,0,0,0&quot;&gt;;
    &lt;/Grid&gt;
    &lt;Image Source=&quot;{Binding 
        ElementName=checkBox
        ,Path=IsChecked
        ,Converter={StaticResource converter}
        ,Mode=OneWay}&quot;&gt;;
&lt;/StackPanel&gt;
</code></pre>
<p>运行效果如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">False</th>
<th style="text-align:center">True</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="/img/2017/02/sp170209_131407.png"><img src="/img/2017/02/sp170209_131407.png" alt=""></a></td>
<td style="text-align:center"><a href="/img/2017/02/sp170209_131440.png"><img src="/img/2017/02/sp170209_131440.png" alt=""></a></td>
</tr>
</tbody>
</table>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Q：为什么ConvertBack方法没有实际代码？</p>
<p>A：Convert是指从Source到Target这个途径，ConvertBack显而易知是从Target到Source这个途径。这里我们是单向的，因此我们不需要给ConvertBack方法写具体的转换代码。如果你遇到的Binding是TwoWay的，那么毫无疑问你就要实现这部分的逻辑。</p>
<p>Q：讲讲Convert方法的参数列表？</p>
<p>A：第一个参数是object类型，最大限度地保证了Converter的重用性，我们可以在方法内部对它的类型进行判断；第二个是方法返回类型（命名有点奇怪就是了，target是指返回值）；第三个是用于把额外的信息传入方法，若需要传递多个信息则可以把信息放入一个集合对象里传入方法。</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WPF </tag>
            
            <tag> .NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binding[1]=数据校验]]></title>
      <url>/2017/02/08/binding-validation/</url>
      <content type="html"><![CDATA[<p>我们知道，属性的存在是为了解决数据有效性的问题，确保暴露出去的数据是合情合理的。在实际中，数据在目标流动过程中，我们一般都需要对其有效性进行验证。我们已经知道，Binding的作用实在Target和Source之间架起了一座数据流动的桥梁，因此我们需要对在这之间流动的数据进行校验。不仅如此，我们还可以进行数据类型的转换，这个在下一篇文章进行讲解，现在我们来看看如何在绑定的时候对数据进行有效性校验。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们的任务是，将一个TextBox（Target）绑定到一个Slider（Source）上，在TextBox输入非Slider的Value的区间值（0到100）时，会显示错误。</p>
<p>UI的XAML代码：</p>
<pre><code class="XML">&lt;StackPanel&gt;
    &lt;TextBox x:Name=&quot;textBox&quot; Margin=&quot;10&quot; Height=&quot;25&quot;/&gt;
    &lt;Slider x:Name=&quot;slider&quot; Margin=&quot;10&quot; Minimum=&quot;-10&quot; Maximum=&quot;100&quot;/&gt;
&lt;/StackPanel&gt;
</code></pre>
<p>看到上面的代码，小伙伴们应该很快发现了一个小细节，为什么Slider的最小值设为-10？这个是别有用意的，因为Binding在验证数据的时候，默认是把Source的数据认为是完全正确的，有问题的数据只可能出现在Target上，因此这里模拟了Source数据异常的情况，并且对Source的数据也进行了校验的步骤。</p>
<p>实现数据的校验是在对Binding的ValidationRules属性赋值，看属性的命名便可知道，这是一个ValidationRule类的集合，准确的类型是Collection<validationrule>。ValidatinRule是一个抽象类，因此我们需要准备它的派生类，实现Validate方法，该方法的返回值是ValidationResult类型对象，如果检验通过，则设置ValidationResult对象的IsValid属性为True，反之为False并为ErrorContent属性设置一个合适的消息内容。现在我们来准备ValidationRule的派生类。</validationrule></p>
<pre><code class="CSharp">class RangeValidationRule : ValidationRule
{
    public override ValidationResult Validate(object value, CultureInfo cultureInfo)
    {
        double data;
        if (double.TryParse(value.ToString(), out data))
        {
            if (data &gt;= 0 &amp;&amp; data &lt;= 100)
            {
                return new ValidationResult(true, null);
            }
        }
        return new ValidationResult(false, &quot;Validation Failed&quot;);
    }
}
</code></pre>
<p>有了这个派生类，我们就可以着手进行将TextBox绑定到Slider上了。</p>
<pre><code class="CSharp">public MainWindow()
{
    InitializeComponent();

    Binding binding = new Binding(&quot;Value&quot;) { Source = this.slider };
    binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged;
    binding.ValidationRules.Add(new RangeValidationRule() { ValidatesOnTargetUpdated = true });
    this.textBox.SetBinding(TextBox.TextProperty, binding);
}
</code></pre>
<p>运行程序后，不论是我们把Slider手动拨到0以下的值还是直接在TextBox里输入小于0的数，TextBox都会显示红色的边框，提示用户数据有问题。运行效果如下：</p>
<p><a href="/img/2017/02/sp170208_214114.png"><img src="/img/2017/02/sp170208_214114.png" alt=""></a></p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>到此我们就已经完成了对数据的校验工作，接下来更进一步。我们刚才说了，ValidatinResult对象携带了一条错误消息，那么，我们如何让这条消息显示出来呢？这里用到了路由事件，我们来把后台代码写的更进一步。</p>
<pre><code class="CSharp">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        Binding binding = new Binding(&quot;Value&quot;) { Source = this.slider };
        binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged;
        binding.ValidationRules.Add(new RangeValidationRule() { ValidatesOnTargetUpdated = true });
        binding.NotifyOnValidationError = true;
        this.textBox.SetBinding(TextBox.TextProperty, binding);
        this.textBox.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(
            (sender, e) =&gt;;
            {
                if (Validation.GetErrors(this.textBox).Count &gt; 0)
                {
                    this.textBox.ToolTip = Validation.GetErrors(this.textBox)[0].ErrorContent.ToString();
                    ToolTipService.SetIsEnabled(this.textBox, true);
                }
            }));
    }
}
</code></pre>
<p>运行效果如下，把鼠标悬停在TextBox上会有小提示出现，这个小提示就是我们在ValidationResult里设置的错误消息。</p>
<p><a href="/img/2017/02/sp170208_214644.png"><img src="/img/2017/02/sp170208_214644.png" alt=""></a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>又到了分析部分，仍然是问答的形式来进行。</p>
<p>Q：后台代码的 ValidatesOnTargetUpdated = true 这句代码是什么意思？</p>
<p>A：这个问题的答案其实在文章里了，我们说了Binding对象默认把来自Source的数据认定为绝对正确，因此我们特意模拟了Source的数据异常的情况，这句代码就是告诉Binding对象，对来自Source的数据也进行校验。</p>
<p>Q：为什么要添加 binding.NotifyOnValidationError = true这句代码？</p>
<p>A：简单的讲就是使得验证失败的时候会触发事件，并执行事件处理器，也就是使得错误消息通过TextBox的ToolTip显示出来。详细请了解路由事件。</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binding[0]=使用ObjectDataProvider对象作为Binding的Source]]></title>
      <url>/2017/02/07/odp-as-binding-source/</url>
      <content type="html"><![CDATA[<p>一般情况下，我们通常使用某个类的实例作为Binding的对象，实例中的某个属性作为Path来消费这些类。现在试想一下这样的情形，我们需要绑定的数据是方法的返回值，这时候我们应该怎么办呢？有小伙伴可能会提出，修改这个类，增加属性将需要的数据暴露出来使用。这样是一个解决方法，但是重新设计底层类的风险和成本比较高，而且在黑盒引用类库的时候我们就不可能这样做了。那么是不是就束手无策了？当然不是，我们可以使用ObjectDataProvider包装一个对象然后作为Binding的数据源。怎么来实现呢？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在的情形是，我引用一个类库，里面有一个Calculator的类，里面有各种算法，其中一个是加法的算法：</p>
<pre><code class="CSharp">class Calculator
{
    public string Add(string arg1, string arg2)
    {
        double x;
        double y;
        if (double.TryParse(arg1, out x) &amp;&amp; double.TryParse(arg2, out y))
        {
            return (x + y).ToString();
        }
        return @&quot;N/A&quot;;
    }
}
</code></pre>
<p>在界面上，准备了三个TextBox，第一个作为Add方法的第一个参数，第二个作为第二个参数，第三个作为Add方法返回值。XAML代码如下：</p>
<pre><code class="CSharp">&lt;StackPanel&gt;
    &lt;TextBox x:Name=&quot;tBArg1&quot; Margin=&quot;10&quot; Height=&quot;25&quot;/&gt;
    &lt;TextBox x:Name=&quot;tBArg2&quot; Margin=&quot;10&quot; Height=&quot;25&quot;/&gt;
    &lt;TextBox x:Name=&quot;tBResult&quot; Margin=&quot;10&quot; Height=&quot;25&quot;/&gt;
&lt;/StackPanel&gt;
</code></pre>
<p>功能上，我要实现在前两个TextBox上输入实数后，在第三个TextBox实时显示出计算结果。过程代码写在一个SetBinding方法里，然后在窗体的构造函数中那个调用这个方法。</p>
<pre><code class="CSharp">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        this.SetBinding();
    }

    private void SetBinding()
    {
        //Create and initial ObjectDataProvider instance
        ObjectDataProvider odp = new ObjectDataProvider();
        odp.ObjectInstance = new Calculator();
        odp.MethodName = &quot;Add&quot;;
        odp.MethodParameters.Add(&quot;&quot;);
        odp.MethodParameters.Add(&quot;&quot;);

        //Create and initial Binding instance
        Binding bindingToArg1 = new Binding(&quot;MethodParameters[0]&quot;)
        {
            Source = odp,
            BindsDirectlyToSource = true,
            UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged
        };

        Binding bindingToArg2 = new Binding(&quot;MethodParameters[1]&quot;)
        {
            Source = odp,
            BindsDirectlyToSource = true,
            UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged
        };

        Binding bindingToResult = new Binding(&quot;.&quot;) { Source = odp };

        //Set binding
        this.tBArg1.SetBinding(TextBox.TextProperty, bindingToArg1);
        this.tBArg2.SetBinding(TextBox.TextProperty, bindingToArg2);
        this.tBResult.SetBinding(TextBox.TextProperty, bindingToResult);
    }
}
</code></pre>
<p>最终的实现效果</p>
<p><a href="/img/2017/02/sp170207_142045.png"><img src="/img/2017/02/sp170207_142045.png" alt=""></a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>OK，现在我们的问题解决了。让我们以问答的形式具体分析一下这个实现过程。</p>
<p>Q：ObjectDataProvider类的作用是什么？</p>
<p>A：文章开头部分就提及到了，ObjectDataProvider类的作用就是将一个<strong>以方法形式暴露数据的对象</strong>包装起来。我们先是创建了一个ObjectDataProvider对象，然后new 一个Calculator实例赋值给它的ObjectInstance属性，这样就完成了将对象包装在ObjectDataProvider对象里的工作。注意这里的ObjectDataProvider对象本身就代表了数据，因此Path写“.”</p>
<p>Q：BindsDirectlyToSource=true这句代码什么意思？</p>
<p>A：这句代码的意思是告诉Binding对象，你把从UI元素采集到数据直接写入其直接Source（也就是ObjectDataProvider对象），而不是ObjectDataProvider对象包装着的Calculator对象里。</p>
<p>Q：如果一个方法有多个重载ObjectDataProvider如何决策使用哪个方法？</p>
<p>A：我们知道，各个重载方法的区别在于方法参数列表的不同。因此，ObjectDataProvider会根据我们传入的参数来决定使用哪个重载方法。这里可以得到的一个结论是：MethodParameters属性对类型是敏感的。</p>
<p>Q：三个TextBox的数据源都是谁？</p>
<p>A：三个TextBox的数据源都是ObjectDataProvider对象。这里体现了WPF的数据驱动UI的理念。</p>
]]></content>
      
        <categories>
            
            <category> Programming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提高Arduino编程体验]]></title>
      <url>/2016/12/29/arduino-ide-for-visualstudio/</url>
      <content type="html"><![CDATA[<p>前阵子学校有个单片机比赛，受其影响突然很想玩板子。于是就买个一块Arduino UNO的国产版ZHONGBEST，就使用上来说和官方原版没有什么区别，最大的区别就是便宜！便宜！便宜！（重说三）</p>
<p>拿到手后，当然迫不及待地上手一个Hello World程序，开始我用的是官方的IDE，试了没问题之后我尝试着去修改代码，然后我发现了什么？没有智能提示！没有智能提示！没有智能提示！或许我是被VS惯坏了，我实在受不了。搜索一波后发现有个扩展叫做 Arduino IDE For Visual Studio（传送门：<a href="https://marketplace.visualstudio.com/items?itemName=VisualMicro.ArduinoIDEforVisualStudio" target="_blank" rel="external">https://marketplace.visualstudio.com/items?itemName=VisualMicro.ArduinoIDEforVisualStudio</a>），安装好了之后打开VS后可以看到界面已经发生了少许的变化，再次尝试着去写代码的时候找回了那种愉悦感 balabala~</p>
<p><a href="/img/2016/12/sp161229_125410.png"><img src="/img/2016/12/sp161229_125410.png" alt=""></a></p>
]]></content>
      
        <categories>
            
            <category> Arduino </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[Talking]]></title>
      <url>/Talking/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[About Me]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p><strong>别人都叫我糯米，小糯米…</strong></p>
<p>在校大学生。</p>
<p>理科男，单身，求勾搭。</p>
<p>喜欢摄影，目前愿望是拥有一部微单。</p>
<p>努力争取拿奖学金买买买。</p>
<p>喜欢设计，不断提高审美中。</p>
<p>程序狗，喜欢做出优雅好用的软件。（虽然还没解锁这个技能）</p>
<p>偶尔会出去骑行，配合摄影感觉不能再好了。</p>
<p>微博:<a href="http://weibo.com/Nomyfan" target="_blank" rel="external">@陈诺米同学</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Articles]]></title>
      <url>/articles/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Contact]]></title>
      <url>/feeback/index.html</url>
      <content type="html"><![CDATA[<p>Contact me with<br><strong><a href="mailto:Myers.Chan@outlook.com?subject=FeebackFromBlog" target="_blank" rel="external">E-mail</a></strong>.<br><strong><a href="http://weibo.com/Nomyfan" target="_blank" rel="external">Weibo</a></strong><br><strong><a href="https://twitter.com/Myers__Chan" target="_blank" rel="external">Twitter</a></strong><br><strong><a href="https://facebook.com/myers.n.chan" target="_blank" rel="external">Facebook</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Friends]]></title>
      <url>/friends/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Photograph]]></title>
      <url>/photograph/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Contact]]></title>
      <url>/contact/index.html</url>
      <content type="html"><![CDATA[<p>Contact me with<br><strong><a href="mailto:Myers.Chan@outlook.com?subject=FeebackFromBlog" target="_blank" rel="external">E-mail</a></strong>.<br><strong><a href="http://weibo.com/Nomyfan" target="_blank" rel="external">Weibo</a></strong><br><strong><a href="https://twitter.com/Myers__Chan" target="_blank" rel="external">Twitter</a></strong><br><strong><a href="https://facebook.com/myers.n.chan" target="_blank" rel="external">Facebook</a></strong></p>
]]></content>
    </entry>
    
  
</search>
